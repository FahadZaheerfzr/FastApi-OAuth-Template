from fastapi import FastAPI, HTTPException, Depends, File, UploadFile, status, Form
from fastapi.middleware.cors import CORSMiddleware
from connection import DB,user_collection
from uuid import uuid4
from authentication import get_hashed_password
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import jwt
from dotenv import dotenv_values
from authentication import token_generator
from models import User


app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
config_credentials = dotenv_values(".env")
# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
ALGORITHM = "HS256"

@app.get("/test-db")
async def test_db_connection():
    """
    Tests the database connection.

    Returns:
        dict: A dictionary containing the message and error (if any).
    """
    try:
        DB.command("ping")
        return {"message": "Database connected successfully"}
    except Exception as e:
        return {"message": "Failed to connect to the database", "error": str(e)}
    
@app.post("/users", status_code=status.HTTP_201_CREATED)
async def create_user( email: str, password: str):
    """
    Creates a new user.

    Args:
        username (str): The username.
        email (str): The email.
        password (str): The password.

    Returns:
        dict: A dictionary containing the message.
    """
    try:
        # Check if the email is already registered
        existing_user = user_collection.find_one({"email": email})
        if existing_user is not None:
            return {"message": "Email already registered"}

        # If the email is not registered, create the user
        user = User(
            id=str(uuid4()),
            email=email,
            password=get_hashed_password(password),
            role= "admin"
        )
        user_data = user.dict()
        user_collection.insert_one(user_data)

        return {"message": "User created successfully"}

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail="Failed to create user",
        )

    
async def get_current_user(token: str = Depends(oauth2_scheme)):
    """
    Gets the current user from the database using the token.

    Args:
        token (str): The token generated by the authentication function.

    Returns:
        dict: The user object.
    """
    try:
        payload = jwt.decode(
            token, config_credentials["SECRET"], algorithms=[ALGORITHM])
        print(payload)
        user = user_collection.find_one({"id": payload.get("id")})
        user = {**user, "_id": str(user["_id"])}
    except:
        raise HTTPException(
            status_code=401, detail="Invalid Email or Password"
        )
    return user

@app.post('/token')
async def generate_token(request_form: OAuth2PasswordRequestForm = Depends()):
    """
    Generates a token for the user.

    Args:
        request_form (OAuth2PasswordRequestForm): The request form containing the email and password.

    Returns:
        dict: A dictionary containing the token and token type.
    """
    try:
        user_obj = await token_generator(request_form.username, request_form.password)
        if user_obj:
            return {"access_token": user_obj["token"], "token_type": "bearer"}
        else:
            return {"message": "login failed"}
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to generate token")


# Login
@app.post('/login')
async def generate_token(request_form: OAuth2PasswordRequestForm = Depends()):
    """
    Generates a token for the user.

    Args:
        request_form (OAuth2PasswordRequestForm): The request form containing the username and password.

    Returns:
        dict: A dictionary containing the token and token type.
    """
    print(request_form.username, request_form.password)
    try:
        user_obj = await token_generator(request_form.username, request_form.password)
        if user_obj:

            print(user_obj)
            return {"user": user_obj, "token_type": "bearer"}
        else:
            return {"message": "login failed"}
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to generate token")
    

@app.get("/users")
async def get_users(token: str = Depends(get_current_user)):
    """
    Gets all the users from the database.

    Args:
        token (str): The token generated by the authentication function.

    Returns:
        list: A list of user objects.
    """
    try:
        users = list(user_collection.find())
        # Convert ObjectId objects to strings
        users = [{**user, "_id": str(user["_id"])} for user in users]
        return users
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to get users")
    
@app.put("/users/{user_id}")
async def update_user(user_id: str, user: User, token: str = Depends(get_current_user)):
    """
    Updates a user.

    Args:
        user_id (str): The user id.
        token (str): The token generated by the authentication function.

    Returns:
        dict: A dictionary containing the message.
    """
    try:
        user_data = user_collection.find_one({"id": user_id})
        if user_data:
            updated_user = user.dict(exclude_unset=True)
            user_collection.update_one({"id": user_id}, {"$set": updated_user})
            return {"message": "User updated successfully"}
        else:
            raise HTTPException(status_code=404, detail="User not found")
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to update user")

@app.get("/users/{user_id}")
async def get_user(user_id: str, token: str = Depends(get_current_user)):
    """
    Gets a user from the database using the user id.

    Args:
        user_id (str): The user id.
        token (str): The token generated by the authentication function.

    Returns:
        dict: The user object.
    """
    print (user_id)
    try:
        user = user_collection.find_one({"id": user_id})
        if user:
            user = {**user, "_id": str(user["_id"])}
            return user
        else:
            raise HTTPException(status_code=404, detail="User not found")
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to get user")

@app.delete("/users/{user_id}")
async def delete_user(user_id: str, token: str = Depends(get_current_user)):
    """
    Deletes a user from the database using the user id.

    Args:
        user_id (str): The user id.
        token (str): The token generated by the authentication function.

    Returns:
        dict: A dictionary containing the message.
    """
    try:
        user = user_collection.find_one({"id": user_id})
        if user:
            user_collection.delete_one({"id": user_id})
            return {"message": "User deleted successfully"}
        else:
            raise HTTPException(status_code=404, detail="User not found")
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to delete user")

